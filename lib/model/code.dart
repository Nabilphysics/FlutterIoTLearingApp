

String cls4_led_serial='//Push Button 1 is attached with GPIO 4 and GND.\n'
    '//Push Button 1 is attached with GPIO 4 and GND.\n'
    '//Push Button 1 is attached with GPIO 4 and GND.\n'
    '//One Led is connected with GPIO 2 or If your ESP32 module contains Builtn in LED   \n'
    'int pushButton1 = 4;\n'
    'int ledPin1 = 2;\n\n'

    'void setup() {\n'
    '// initialize serial communication at 9600 bits per second:\n'
    'Serial.begin(9600);\n'
    '// make the pushbutton pin an input:\n'
    'pinMode(pushButton1, INPUT_PULLUP);\n'
    'pinMode(ledPin1, OUTPUT);\n'
    '}\n'
    '\nvoid loop() {\n'
    '// read the input pin:\n'
    'int buttonState1 = digitalRead(pushButton1);\n'
    '// print out the state of the button:\n'
    'Serial.println(buttonState1);\n'
    'if(buttonState == LOW){ \n'
    'delay(100); // delay in between reads for stability\n'
    'if(buttonState1 == 0)\n'
    '{\n'
    'digitalWrite(ledPin1, HIGH);\n'
    '}\n'
    'else{\n'
    'digitalWrite(ledPin1, LOW);\n'
    '}\n'
    '}\n';

String cls4_led_control_with_serial_code=
    '\nuint8_t ledPin = 2; //GPIO 2'
    '\nchar state;'
    '\nvoid setup() {'
    '\npinMode(ledPin, OUTPUT);'
    '\nSerial.begin(9600);'
    '\n}'
    '\nvoid loop() {'
    '\nif (Serial.available() > 0) {'
    '\nstate = Serial.read();'
    "'if (state == 'H' || state == 'h') {'"
'\ndigitalWrite(ledPin, HIGH);'
'\n }'
"\n if (state == 'L' || state == 'l') {"
'\n   digitalWrite(ledPin, LOW);'
'\n }'
'\n}'
'\nSerial.println(state);'
'\ndelay(50);'
'\n}';

String cls4_debounce=
  '\n//Debounce Example'

  '\n//Each time the input pin goes from LOW to HIGH (e.g. because of a push-button'
  '\n//press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There is a'
  '\n//minimum delay between toggles to debounce the circuit (i.e. to ignore noise).'

    '\n//The circuit:'
'\n- //LED attached from pin 13 to ground'
'\n-// pushbutton attached from pin 2 to GND'
    '\n //- Internally Pullup (This pin is already internally HIGH)'

    '\n//created 21 Nov 2006'
    '\n//by David A. Mellis'
    '\n//modified 30 Aug 2011'
    '\n//by Limor Fried'
    '\n//modified 28 Dec 2012'
    '\n// by Mike Walters'
    '\n// modified 30 Aug 2016'
    '\n//by Arturo Guadalupi'
    '\n// modified 16 Sep 2018'
    '\n// by Syed Razwanul Haque (Nabil) , CRUX'

    '\n//This example code is in the public domain.'
    '\n//http://www.arduino.cc/en/Tutorial/Debounce'
    '\n // constants wont change. They are used here to set pin numbers:'
'\nconst int buttonPin = 2;    // the number of the pushbutton pin'
'\nconst int ledPin = 13;      // the number of the LED pin'

'\n// Variables will change:'
'\nint ledState = HIGH;         // the current state of the output pin'
'\nint buttonState;             // the current reading from the input pin'
'\nint lastButtonState = LOW;   // the previous reading from the input pin'

'\n// the following variables are unsigned longs because the time, measured in'
'\n// milliseconds, will quickly become a bigger number than can be stored in an int.'
'\nunsigned long lastDebounceTime = 0;  // the last time the output pin was toggled'
'\nunsigned long debounceDelay = 50;    // the debounce time; increase if the output flickers'

'\nvoid setup() {'
'\npinMode(buttonPin, INPUT_PULLUP);'
'\npinMode(ledPin, OUTPUT);'

'\n// set initial LED state'
'\ndigitalWrite(ledPin, ledState);'
'\n}'

'\nvoid loop() {'
'\n// read the state of the switch into a local variable:'
'\nint reading = digitalRead(buttonPin);'

'\n// check to see if you just pressed the button'
'\n// (i.e. the input went from LOW to HIGH), and you have waited long enough'
'\n// since the last press to ignore any noise:'

'\n// If the switch changed, due to noise or pressing:'
'\nif (reading != lastButtonState) {'
'\n // reset the debouncing timer'
'\n lastDebounceTime = millis();'
'\n}'

'\nif ((millis() - lastDebounceTime) > debounceDelay) {'
'\n // whatever the reading is at, it is been there for longer than the debounce'
'\n  // delay, so take it as the actual current state:'

'\n // if the button state has changed:'
'\n if (reading != buttonState) {'
'\n   buttonState = reading;'

'\n   // only toggle the LED if the new button state is LOW'
'\n   if (buttonState == LOW) {'
'\n     ledState = !ledState;'
'\n   }'
'\n }'
'\n}'

'\n// set the LED:'
'\ndigitalWrite(ledPin, ledState);'

'\n// save the reading. Next time through the loop, it will be the lastButtonState:'
'\nlastButtonState = reading;'
'\n}';

String cls4_touch_code=

  '\n//ESP32 Touch Test and LED Ctrl'
    '\n//Touch pin ==> Touch0 is T0 which is on GPIO 4 (D4).'
    '\n//LED pin   ==> D2'

'\n#define TOUTCH_PIN T0 // ESP32 Pin D4'
    '\n#define LED_PIN 2'
    '\nint touch_value = 100;'

    '\nvoid setup()'
    '\n{'
    '\n Serial.begin(115200);'
    '\ndelay(100); // give me time to bring up serial monitor'
    '\nSerial.println("ESP32 Touch Test");'
    '\npinMode(LED_PIN, OUTPUT);'
    '\ndigitalWrite (LED_PIN, LOW);'
    '\n}'

    '\nvoid loop()'
    '\n{'
    '\ntouch_value = touchRead(TOUTCH_PIN);'
    '\nSerial.println(touch_value);  // get value using T0 '
    '\nif (touch_value < 50)'
    '\n{'
    '\n  digitalWrite (LED_PIN, HIGH);'
    '\n}'
    '\nelse'
    '\n{'
    '\n  digitalWrite (LED_PIN, LOW);'
'\n }'
    '\n delay(100);'
    '\n}';


String cls5_wifi_scan_code=

        '\n#include "WiFi.h"'
        '\n'
        '\nvoid setup()'
        '\n{'
        '\nSerial.begin(115200);'
        '\n'
       // '\n// Set WiFi to station mode and disconnect from an AP if it was previously connected'
        '\nWiFi.mode(WIFI_STA);'
        '\nWiFi.disconnect();'
        '\ndelay(100);'
        '\n'
        '\nSerial.println("Setup done");'
        '\n}'
        '\n'
        '\nvoid loop()'
        '\n{'
        '\nSerial.println("scan start");'
        '\n'
       // '\n//WiFi.scanNetworks will return the number of networks found'
        '\nint n = WiFi.scanNetworks();'
        '\nSerial.println("scan done");'
        '\nif (n == 0) {'
        '\nSerial.println("no networks found");'
        '\n} else {'
        '\nSerial.print(n);'
        '\nSerial.println(" networks found");'
        '\nfor (int i = 0; i < n; ++i) {'
        //'\n// Print SSID and RSSI for each network found'
        '\nSerial.print(i + 1);'
        '\nSerial.print(": ");'
        '\nSerial.print(WiFi.SSID(i));'
        '\nSerial.print(" (");'
        '\nSerial.print(WiFi.RSSI(i));'
        '\nSerial.print(")");'
        '\nSerial.println((WiFi.encryptionType(i) == WIFI_AUTH_OPEN)?" ":"*");'
        '\ndelay(10);'
        '\n}'
        '\n}'
        '\nSerial.println("");  '
        '\n'
        '\n// Wait a bit before scanning again  '
        '\ndelay(5000);  '
        '\n}';

String cls5_wifi_connect_code =
      '\n#include <WiFi.h>'
    '\nconst char* ssid     = "yourssid";'
    '\nconst char* password = "yourpasswd";'

    '\nvoid setup()'
    '\n{'
    '\nSerial.begin(115200);'
    '\ndelay(10);'
  // We start by connecting to a WiFi network
    '\nSerial.println();'
    '\nSerial.print("Connecting to ");'
    '\nSerial.println(ssid);'
    '\nWiFi.begin(ssid, password);'

    '\nwhile (WiFi.status() != WL_CONNECTED) {'
    '\ndelay(500);'
    '\nSerial.print(".");'
    '\n}'

    '\nSerial.println("");'
    '\nSerial.println("WiFi connected.");'
    '\nSerial.println("IP address: ");'
    '\nSerial.println(WiFi.localIP());'
    '\n}'
    '\nvoid loop(){'
    '\n}';

String cls5_wifi_hotspot =
        '\n#include <WiFi.h>'
        '\nconst char *ssid = "MyESP32AP";// Hotspoot ID'
        '\nconst char *password = "testpassword"; // Password Require to Join'
        '\n'
        '\nvoid setup() {'
        '\n'
        '\nSerial.begin(115200);'
        '\nWiFi.softAP(ssid, password);'
        '\n'
        '\nSerial.println();'
        '\nSerial.print("IP address: ");'
        '\nSerial.println(WiFi.softAPIP());'
        '\n}'
        '\n'
        '\nvoid loop() {';